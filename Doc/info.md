
# План разработки EnoddGameEngine через практические мини-игры

Разрабатывается пользовательский игровой движок **EnoddGameEngine** с постепенным наращиванием возможностей. Подход основан на создании ряда **мини-игр** (например, «Змейка», Tetris, 2D-платформер и др.), в ходе которых последовательно реализуются и отлаживаются модули движка. Такой метод позволяет поэтапно освоить ключевые аспекты: *игровой цикл, обработка ввода, рендеринг, звук, обработка столкновений* и т.д.. Ниже план разбит на два уровня: сначала описывается **развитие ядра движка** (архитектура, подсистемы, этапы и используемые библиотеки), а затем – **этапы разработки учебных игр**, где каждая игра ставит конкретные цели для движка, содержит список задач (TODO) и отмечает, какие компоненты движка при этом задействованы.

## Развитие ядра EnoddGameEngine (архитектура и подсистемы)

Основу движка составит модульная архитектура с использованием шаблона **Entity-Component-System (ECS)** для игрового мира. ECS строго разделяет *данные* и *логику*: компоненты хранят только данные объекта, а системы содержат код обработки этих данных. Это обеспечивает гибкость и масштабируемость логики игры. Движок будет состоять из отдельных подсистем (модулей) – графический рендерер, система ввода, аудио, физика, UI и др. – которые взаимодействуют через ECS и систему событий. Мы будем опираться на проверенные библиотеки: **SFML** для работы с окном, 2D-графикой и ввода (SFML предоставляет простое API к окну, графике и звуку и хорошо подходит для этих целей), **OpenAL** для воспроизведения звука (кроссплатформенный API 3D-аудио), **Bullet Physics** для физических расчетов (открытый движок для обнаружения коллизий и симуляции динамики тел) и др. Ниже перечислены этапы развития ядра движка с указанием ключевой функциональности каждого этапа и используемых технологий.

### Этап 1: Минимальный MVP ядра (рендеринг, ECS, события)

На первом этапе создается минимально работоспособное ядро движка – **MVP (Minimum Viable Product)**. Цель – обеспечить базовый цикл игры с отображением на экране и управлением объектами через ECS. Основные задачи этапа:

* **Инициализация окна и рендерера:** подключить SFML для создания окна и отрисовки простых 2D-примитивов (например, отрисовать тестовый спрайт или форму). Настроить базовый цикл рендеринга: очистка экрана, рисование объектов, отображение результата на экран каждый кадр.
* **Реализация ядра ECS:** спроектировать системы **Entity-Component-System** для игры. Создать класс сущности (Entity) и менеджер сущностей, позволяющий создавать/удалять игровые объекты. Определить структуру компонентов (Component) – например, компоненты Position, Sprite/Graphics – которые хранят данные (позиция, спрайт и др.). Компоненты должны содержать только данные, без логики. Реализовать базовые системы (System) для обновления и рендеринга: например, систему отрисовки, проходящую по сущностям с компонентом Sprite и выводящую их на экран. Логика обработки сосредоточена в системах (они не хранят собственного состояния, только оперируют данными компонентов).
* **Игровой цикл и обработка событий:** реализовать основной *игровой цикл* (game loop), который выполняется каждый кадр: обработка ввода, обновление систем ECS, отрисовка. Внедрить простейшую **систему событий**: получать события из окна SFML (например, нажатия клавиш, закрытие окна) и передавать их в движок. На MVP этапе достаточно обработать событие закрытия окна и базовые клавиши. *SFML* будет использоваться для управления окнами, рендеринга и получения событий ввода.
* **Тестирование MVP:** Создать простую сцену для проверки: например, добавить сущность с компонентами Position и Sprite, заставить её двигаться (изменяя координаты каждый кадр) и убедиться, что на экране объект перемещается. Это подтвердит работу цикла, ECS и рендеринга.

На выходе этапа движок должен уметь открывать окно, отображать примитивный объект и обрабатывать простейший ввод. **Используемые технологии:** SFML (модули Window и Graphics) для окна и 2D-рисования, собственная реализация ECS (либо с помощью библиотеки, например EnTT, либо самостоятельно). Этот фундамент послужит базой для дальнейших шагов.

### Этап 2: Система ввода (расширенный ввод пользователя)

На втором этапе ядро дополняется полноценной **подсистемой ввода**. Цель – обеспечить гибкое и удобное получение управляющих действий пользователя из разных источников (клавиатура, мышь, геймпад) и их обработку внутри движка.

Основные доработки:

* **Обработка клавиатуры и мыши:** Расширить использование событий SFML: отлавливать нажатия/отпускания клавиш, движения и клики мыши. Ввести абстракцию для ввода – например, класс InputManager, который отслеживает текущее состояние нужных клавиш и генерирует события действий (например, «влево», «прыжок») для игровых систем. Обеспечить, чтобы на каждом кадре игрового цикла происходило обновление состояния ввода и генерация событий ECS (например, система контроля игрока читает InputManager).
* **Поддержка геймпада (опционально):** Если планируется, на этом этапе можно подключить обработку джойстиков/геймпадов (SFML имеет модуль Joystick). Это не обязательно для 2D-миниигр, но добавит модульности: ввод абстрагирован от конкретного устройства.
* **Конфигурация управляющих клавиш:** Предусмотреть возможность настройки клавиш управления (например, хранить раскладку в конфигурационном файле, что может использоваться системой сериализации позже). Пока достаточно захардкодить основные клавиши для простоты.
* **Тестирование ввода:** Добавить временно вывод отладочных сообщений (логирование) при нажатии клавиш, чтобы убедиться, что InputManager корректно распознаёт команды. Например, нажимая стрелки, выводить в консоль направление.

После этого этапа движок сможет надежно обрабатывать пользовательский ввод. **Используемые библиотеки:** SFML (модуль Window) для получения событий клавиатуры/мыши; собственная логика управления. Данный функционал будет сразу применён в первой тестовой игре («Змейка») для контроля персонажа.

### Этап 3: Аудиоподсистема (звук и музыка)

На третьем этапе интегрируется **аудио**. Цель – добавить в движок возможность воспроизводить звуковые эффекты и музыку, что необходимо для полноты игровых возможностей.

Ключевые шаги:

* **Выбор аудиобиблиотеки:** SFML содержит аудио-модуль, основанный на OpenAL, который позволяет легко воспроизводить звуки и музыку. Можно использовать его для простоты. Альтернативно – напрямую подключить **OpenAL** для обучения низкоуровневому аудио API. OpenAL – кроссплатформенный API для 3D-звука, широко применимый в играх. Для начала рационально использовать высокоуровневый интерфейс SFML (классы `sf::Sound`, `sf::Music`), а при необходимости особых аудиоэффектов – рассмотреть OpenAL.
* **Загрузка и воспроизведение звуков:** Реализовать модуль AudioManager в движке. Обеспечить загрузку аудиофайлов (например, WAV/OGG) из ресурсов и управление ими. Добавить возможность воспроизводить короткие звуковые эффекты (например, звук «поглощения» еды в змейке или уничтожения линии в Tetris) и фоновую музыку (цикличное воспроизведение).
* **Настройки звука:** Добавить базовое управление громкостью, возможность включать/выключать звук. Это можно хранить в настройках и при помощи системы событий информировать аудиосистему.
* **Тестирование аудио:** Для проверки – воспроизвести тестовый звук при каком-либо событии (например, при нажатии определённой клавиши) и убедиться, что звук проигрывается. Также протестировать фоновую музыку (если имеется короткий музыкальный файл).

На этом этапе движок получает аудио-возможности. **Используемые технологии:** SFML Audio (либо OpenAL напрямую). Библиотека **OpenAL** обеспечивает эффективный рендеринг многоканального звука и может имитировать объёмные эффекты (затухание, доплеровский эффект и пр.), что пригодится при дальнейшем развитии (например, в платформере для звуков в пространстве). Но для 2D-игр достаточно воспроизводить звуки без позиционирования.

### Этап 4: Физика и обработка коллизий

Четвёртый этап – внедрение **физического движка** для обработки движения объектов и их столкновений. В 2D-играх это в первую очередь расчёт столкновений и простая динамика (гравитация, отражения), но закладывать подсистему физики стоит с учётом возможного масштабирования.

Основные работы:

* **Выбор физической библиотеки:** Рассмотреть использование **Bullet Physics** – мощного открытого движка физики, обеспечивающего обнаружение коллизий и симуляцию rigid body динамики. Bullet ориентирован на 3D, но его можно применять и в 2D (задавая всем объектам фиксацию по одной оси) или как универсальное решение на будущее. Альтернативой является специально 2D-ориентированный движок **Box2D**, который проще для чисто 2D-игр. Для целей обучения можно выбрать Bullet, чтобы изучить его API, либо Box2D для более простого внедрения.
* **Интеграция физики в ECS:** Создать компонент **Physics (RigidBody/Collider)**, содержащий свойства физического тела (форма коллайдера, масса, скорость и т.п.). Внедрить систему PhysicsSystem, которая каждый кадр обновляет физические объекты: применяет силы (например, гравитацию), интегрирует движение и проверяет столкновения. Для этого придется создать физический *мир* (world) Bullet/Box2D, добавлять туда объекты-сущности с компонентом Physics и обрабатывать коллизии через колбэки или события.
* **Обработка столкновений:** Настроить генерацию событий при коллизиях – например, при столкновении игрока с врагом или с поверхностью. Физический движок позволит определять контакты; нужно связать это с игровой логикой (например, уничтожить объект при столкновении).
* **Тестирование на примере:** На данном этапе можно создать тестовую сцену или небольшую демо-игру: например, простую «прыгалку» – шарик, падающий на платформу, отскакивающий от неё. Это проверит работу гравитации и столкновений. Либо отладить сразу на следующей запланированной игре (2D-платформере).

После реализации этого этапа движок сможет обрабатывать перемещения с учетом физических законов и столкновения объектов. **Используемые технологии:** библиотека Bullet Physics (подключается на данном этапе) для расчёта коллизий и динамики; либо Box2D как облегченный вариант для 2D. Выбор Bullet оправдан, если в перспективе планируется 3D-расширение движка или сложная физика, поскольку он широко используется в играх и поддерживает многое из коробки.

### Этап 5: Система UI (пользовательский интерфейс)

На пятом этапе добавляется подсистема **UI (User Interface)**, позволяющая отображать текстовую и графическую информацию поверх игрового мира: меню, счета, здоровье и пр. Это важно для полноценных игр (отображение счета в Tetris, очков и уровня здоровья в платформере, экран паузы/меню и т.д.).

План работ:

* **Текст и графические элементы:** Использовать возможности SFML по выводу текста (класс `sf::Text` и шрифты) для отображения чисел, сообщений и пр. Реализовать компонент **TextLabel** (содержит строку текста, шрифт, размер) и соответствующую систему для рендеринга UI-элементов поверх игры. Аналогично можно создать компонент **UIElement** для простых графических элементов интерфейса (например, прямоугольник панели здоровья).
* **Слой интерфейса:** Внутри игрового цикла отрисовку UI логично делать *после* отрисовки игрового мира, чтобы элементы накладывались поверх. Можно организовать отдельный менеджер UI или просто дополнительную систему `UISystem`, проходящую по сущностям-интерфейсным элементам.
* **Структура UI:** На данном этапе достаточно несложной иерархии: например, меню или окно можно представить как группу UI-сущностей (заголовок, кнопки), которые показываются/скрываются. Реакцию на нажатия (например, кнопки меню) можно реализовать через проверку координат мыши и событий ввода.
* **Использование библиотек для UI (опционально):** Для ускорения разработки можно подключить готовую библиотеку GUI, совместимую с SFML, например **TGUI** или **ImGui** (для отладочных окон). Однако, написание собственного минимального UI-системы тоже полезно. На этом этапе можно начать с примитивного вывода текста и простых форм через SFML.
* **Тестирование UI:** Реализовать, к примеру, отображение счета игры. После этого этапа при разработке Tetris можно будет показать набранные очки, а в платформере – нарисовать индикатор здоровья. Проверить корректность: обновляется ли текст при изменении данных (например, счет увеличивается).

В результате движок получает возможность отображать информационные элементы и диалоги. **Используемые технологии:** SFML (Text, Font из модуля Graphics) для отрисовки текста; возможно, внешняя GUI-библиотека для сложных элементов (необязательно). Этот модуль делает движок пригодным для игр с интерфейсом, улучшая пользовательский опыт.

### Этап 6: Сериализация и работа с данными

На шестом этапе планируется внедрить систему **сериализации данных** – сохранения и загрузки состояния игры, уровней, настроек. Это необходимо для чтения ресурсов (например, описаний уровней для платформера) и сохранения прогресса игрока.

Задачи этапа:

* **Хранение игровых ресурсов:** Создать менеджер ресурсов, отвечающий за загрузку изображений, звуков, конфигураций из файлов. Он должен предотвращать дублирующую загрузку (кэширование ресурсов) и предоставлять доступ компонентам (например, компонент Sprite может запрашивать текстуру по имени). Формат ресурсов – простые файлы (PNG, OGG, шрифты и т.д.), которые уже должны загружаться через SFML.
* **Формат сериализации:** Выбрать формат для хранения игровых данных. Для начала удобно использовать текстовый формат JSON или YAML для описания уровней, настроек и т.п. (например, список координат стен уровня, рекорды игроков). Встроить библиотеку для работы с JSON (например, *nlohmann/json* для C++). Также можно использовать двоичный формат или собственный, но JSON/YAML упростит отладку.
* **Сохранение/загрузка состояния:** Реализовать функции сохранения состояния игры (например, записи счета, текущего уровня) в файл и загрузки обратно. В рамках учебных мини-игр, сериализация может потребоваться в платформере (загрузка уровня из файла) или для сохранения рекордов Tetris. Создать класс Serializer, умеющий проходить по необходимым компонентам/объектам и записывать их данные (или восстанавливать).
* **XML для уровней (опционально):** Альтернативно JSON, можно использовать простые текстовые представления (CSV для уровня-змейки или матрицы для Tetris). Выбор не критичен, главное – реализовать принцип.
* **Тестирование сериализации:** Протестировать на простом примере: сохранить конфигурацию (например, управление, или массив позиций) в JSON, затем загрузить и убедиться, что полученные данные идентичны исходным. Для уровня – можно создать файл уровня для платформера (набор платформ), загрузить его и отобразить через движок.

После этого этапа движок получает гибкость в управлении контентом: можно легко добавлять новые уровни, настраивать параметры игр без перекомпиляции, а также сохранять результаты. **Используемые технологии:** библиотеки парсинга JSON/YAML при необходимости; стандартные средства C++ для файлового ввода-вывода.

### Этап 7: Тестирование и отладка движка

На седьмом этапе внимание уделяется качеству – внедряются средства **тестирования и отладки**. Цель – обеспечить стабильность платформы, упрощение поиска ошибок и возможность расширения без регрессий.

Основные инициативы:

* **Автоматизированное тестирование модулей:** Написать unit-тесты для ключевых компонентов движка. Например, протестировать работу ECS (добавление/удаление сущностей, корректность присвоения компонентов), математику (функции векторов, столкновение прямоугольников), сериализацию (преобразование объектов в JSON и обратно) и т.д. Можно использовать фреймворк юнит-тестирования (например, GoogleTest) или встроить простой самописный.
* **Регрессионное тестирование игр:** После реализации каждой мини-игры, сохранять ее как пример/тест. При внесении изменений в движок проверять, не сломалась ли прежняя игра. Например, после изменения ECS – снова запустить «Змейку» и убедиться, что она работает как раньше. Этот подход «разработка через игры» сам по себе служит тестированием: каждая следующая игра валидирует новые и старые возможности.
* **Профилирование и производительность:** Добавить замеры времени обновления и рендеринга (хотя бы простое измерение FPS или длительности кадра). Это поможет выявить узкие места при усложнении игр. При необходимости – оптимизировать, например, систему рендеринга или поиск коллизий (использовать пространственные структуры).
* **Документирование кода:** В рамках отладки полезно документировать архитектуру – описать, как добавлять новые системы или компоненты. Это не программное тестирование, но повышает качество проекта.
* **Отладочные визуализации (опционально):** Встроить возможность рисовать отладочную информацию: коллайдеры (рамки вокруг спрайтов), сетку координат, выводить текущее количество сущностей и т.п. Это можно сделать условно (например, клавиша F1 включает отладочный режим).

Результатом этапа станет более надежный код базы. **Используемые технологии:** фреймворки тестирования (по желанию), профилировщики. Также можно применить ImGui для создания отладочного интерфейса (отображение переменных, графиков FPS) – это облегчит отладку во время разработки игр.

### Этап 8: Логирование и диагностирование

Восьмой этап дополняет движок системой **логирования** и диагностических сообщений. Это тесно связано с тестированием и нужно для понимания внутренних процессов во время разработки игр.

План действий:

* **Встраивание логгера:** Реализовать класс Logger (или подключить библиотеку типа spdlog) для вывода сообщений разного уровня: информация, предупреждения, ошибки. Логи можно выводить в консоль, в файл или во встроенную консоль движка.
* **Логирование ключевых событий:** Добавить журналы при важных действиях: создание/удаление сущностей, загрузка ресурсов, коллизии, изменения состояний игры. Например, в «Змейке» логировать событие смерти или съедения яблока (с координатами), в физическом движке – факт столкновения.
* **Уровни логирования и фильтрация:** Предусмотреть возможность переключать подробность логов (особенно в отладочном режиме). В боевом режиме игры можно отключать подробный лог, а при разработке – включать.
* **Диагностические сведения:** Вывод текущего числа кадров в секунду (FPS), потребления памяти, количества объектов и т.д. – либо через лог, либо на экран (в режиме отладки). Эти данные помогут следить за производительностью.
* **Тестирование:** Проверить, что при разных ситуациях логирование работает: например, сгенерировать умышленные ошибки (отсутствие файла ресурса) и убедиться, что они корректно записываются в лог.

После этого этапа разработчик (вы) будет иметь инструмент отслеживания поведения движка во время выполнения игр, что облегчает выявление проблем.

**Итог по ядру:** К концу разработки ядра EnoddGameEngine будет обладать следующими основными модулями:

| Подсистема (модуль)               | Назначение и функции                                                                                                                              | Библиотеки/технологии                                                                                      |
| --------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------- |
| **Графика/Рендеринг**             | Отрисовка 2D-объектов, управление окном, настройка камеры/вида.                                                                                   | SFML (модули Window, Graphics)                                                                             |
| **ECS (Entity-Component-System)** | Управление игровыми объектами: сущности, компоненты данных, системы логики. Позволяет гибко добавлять новые типы объектов и поведения.            | Собственная реализация или готовый ECS-фреймворк (EnTT и др.). Следует принцип разделения данных и логики. |
| **Событийная система**            | Обмен сообщениями между подсистемами и игровыми объектами. Обработка вводных событий (нажатия клавиш, клики) и игровых (столкновения, состояния). | SFML events (ввод) + собственная шина событий для игровых сообщений.                                       |
| **Система ввода**                 | Обработка ввода пользователя с клавиатуры, мыши, геймпада. Преобразует сырые события в понятные командам игры.                                    | SFML (получение событий) для клавиатуры/мыши; модуль Joystick для геймпадов.                               |
| **Аудио-подсистема**              | Воспроизведение звуковых эффектов и музыки, управление громкостью.                                                                                | SFML Audio (внутри использует OpenAL) или напрямую OpenAL для гибкости.                                    |
| **Физический движок**             | Симуляция физики: перемещение с учетом сил, обнаружение и обработка столкновений, эффекты гравитации.                                             | Bullet Physics (3D/2D физика); альтернативно Box2D для 2D.                                                 |
| **UI/Интерфейс**                  | Отображение статического и динамического текстового и графического интерфейса: меню, показатели, кнопки.                                          | SFML (текст, примитивы). Возможно подключение GUI-библиотеки (TGUI, ImGui - для отладки).                  |
| **Сериализация**                  | Загрузка и сохранение данных игры: уровни, настройки, прогресс. Форматирование данных для внешнего хранения и восстановление.                     | Библиотека для работы с JSON/YAML или собственный парсер; STL (fstream).                                   |
| **Логирование**                   | Вывод отладочной и диагностической информации, ошибок.                                                                                            | spdlog или аналог, либо простой вывод в консоль.                                                           |
| **Тестирование**                  | Набор автотестов и встроенных проверок для устойчивости изменений.                                                                                | Фреймворк тестов (GoogleTest и др.) или собственные средства.                                              |

## Этапы разработки учебных мини-игр (практическая реализация)

После создания базового ядра по вышеописанному плану, осуществляется цикл из **мини-игр**, каждая из которых служит учебным примером и тестом для движка. Каждая игра последовательно усложняется, требуя подключения новых модулей движка или доработки существующих. Ниже приведены планируемые игры и этапы их разработки:

### Учебная игра 1: «Змейка»

**Цели для движка:** Игра «Змейка» – простейшая аркада, идеально подходящая для отладки базового функционала движка. Основной акцент делается на проверке работы ECS и системы ввода. В процессе разработки «Змейки» будут испытаны: **ECS** (представление сегментов змеи и еды как сущностей), **система ввода** (управление направлением движения), базовый **рендеринг** (отрисовка игрового поля и объектов) и обработка простых **событий** (столкновение с границей или собой для завершения игры). Аудио и физика на этом этапе не требуются, что позволяет сфокусироваться на MVP функциональности.

**TODO – Задачи разработки «Змейки»:**

1. **Игровое поле и сущности:** Определить игровое поле (например, размеры сетки 20x20 клеток). Создать сущность *змея*, состоящую из нескольких сегментов (можно моделировать как несколько сущностей с компонентом Position, объединённых логикой или как одну сущность с перечнем сегментов). Создать сущность *еда* (яблоко) с компонентами Position и Sprite (может быть отрисована как квадрат или кружок).
2. **Управление движением змеи:** Реализовать систему SnakeMovementSystem, которая каждый тик перемещает змею. Хранить текущее направление движения (например, компонент Direction у головы змеи). Считывать ввод: при нажатии стрелок менять направление (но запрещать поворот на 180°). Использовать события или опрос InputManager для изменения направления.
3. **Рост и логика еды:** Когда голова змеи достигает клетки с едой, генерировать событие «съедено яблоко». Обработчик должен увеличить длину змеи (добавить сегмент – например, добавить сущность сегмента в хвост) и увеличить счет игры. Одновременно переместить яблоко в новую случайную свободную позицию. Эти действия проверят работу ECS: динамическое добавление сущностей во время игры и корректность обновления состояния.
4. **Обработка столкновений (простая):** Проверять условия конца игры: столкновение головы змеи с границами поля или с собственным телом. Реализовать это логикой в системе движения (например, перед перемещением головы проверить, не выйдет ли новая позиция за границу или не совпадет ли с позицией одного из сегментов). При обнаружении столкновения – сигнализировать о конце игры (можно через событие GameOver).
5. **Отрисовка игры:** Система рендеринга должна уметь отображать всех сегментов змеи и еду на экране. На MVP этапе можно представить их простыми цветными прямоугольниками (например, `sf::RectangleShape`). Каждая сущность-сегмент и еда имеют компонент Sprite/Shape, понятный рендер-системе. **UI:** Опционально, вывести на экран счет (количество съеденных яблок) – для этого потребуется текстовый элемент (что станет первым использованием подсистемы UI, если она уже реализована к этому моменту).
6. **Скорость игры и цикл:** Настроить таймер или задержку, чтобы змея перемещалась дискретно (например, раз в 100ms), а не каждый кадр. Можно реализовать простой таймер в системе змеи или управлять через фиксированный шаг обновления (game update tick). Это потребует внимательного обращения с игровым циклом.
7. **Тестирование и отладка:** Запустить игру и проверить управляемость. Использовать логирование для отладки: выводить позиции сегментов, направления, столкновения. Убедиться, что игра корректно реагирует на ввод, что змея растет, а игра завершается при столкновении. При необходимости скорректировать системы ECS или ввода, выявив проблемы. Например, если ввод обрабатывается слишком медленно или пропускает нажатия, доработать InputManager.

**Модули движка в «Змейке»:**

* *ECS:* активно используется для создания динамических объектов (сегменты, еда) и удаления их (например, при рестарте игры). Проверяется базовая работа компонентов и систем.
* *Система ввода:* задействована для управления стрелками. В ходе разработки можно выявить, достаточно ли хороша абстракция ввода (например, нужна ли буферизация нажатий для плавности).
* *Рендеринг:* проверяется способность движка отрисовывать множество объектов (сегменты змеи) без артефактов, работать с базовыми формами или спрайтами.
* *Событийная модель:* используется упрощенно (события окончания игры или съедения предмета). Можно проверить механизм глобальных событий.
* *UI:* не критична, но можно задействовать минимально (вывод счета). Если к моменту разработки змейки модуль UI не готов, счет можно показывать в консоли или просто не отображать.

### Учебная игра 2: Tetris

**Цели для движка:** Игра **Tetris** служит следующим этапом усложнения. Она добавляет требования к отображению множества динамических объектов, более сложной логике обновления, а также вовлекает новые подсистемы: **аудио** (звуки при удалении линий), **UI** (отображение счета, уровня), базовое управление падением фигур. Tetris проверит эффективность ECS при большом числе однотипных объектов (блоки) и корректность обработки коллизий в сетке без полноценного физического движка (логические столкновения). Также здесь целесообразно впервые использовать подсистему **аудио** (для эффектов) и убедиться в удобстве сериализации (например, хранение конфигураций фигур).

**TODO – Задачи разработки Tetris:**

1. **Представление игрового поля:** Описать сетку 10x20 клеток для стакана Tetris. Стакан можно представить двумерным массивом или, в контексте ECS, как набор занятых клеток. Проще всего реализовать логику вне ECS (через массив), но можно и через сущности: каждую падающую фигуру считать сущностью, состоящей из 4 блоков, а упавшие блоки – отдельные сущности, прикрепленные к «полю».
2. **Спрайты и графика:** Подготовить спрайты или цветные квадраты для блоков Tetris. Все 7 типов тетромино можно задать в виде шаблонов (матрицы 4x4 или список координат). Убедиться, что графическая подсистема может отрисовать до \~200 блоков (максимально при заполненном поле) без снижения производительности.
3. **Логика падения фигур:** Разработать систему **TetrisGameplaySystem**. Раз в фиксированный интервал времени опускать активную фигуру вниз на одну клетку. Если фигура достигает дна или сталкивается с уже упавшими блоками, зафиксировать ее: добавить блоки фигуры в массив поля (или превратить падающую сущность в несколько статичных сущностей-блоков, «привязанных» к координатам). Затем создать новую падающую фигуру наверху. Эта система должна использовать **события** или проверку состояния, аналогично змейке, но сложнее: проверка коллизий фигуры с препятствиями (границы стакана, занятые клетки). Здесь отрабатывается сложная игровая логика поверх простых возможностей движка.
4. **Управление фигурой (ввод):** Использовать систему ввода для перемещения фигуры: влево, вправо и вращение. При нажатии стрелки вбок – попытаться сместить фигуру (если клетка свободна). При нажатии кнопки вращения – повернуть фигуру (трансформировать ее координаты согласно Tetris-правилам). Вращение – нетривиальная часть (известно, что в Tetris нужны проверки валидности после поворота), но для учебного проекта можно обойтись простыми проверками или реализовать базовый `Super Rotation System`. **Важно:** реакция на ввод должна происходить мгновенно и не зависеть от падающего таймера (т.е. отслеживать нажатия "влево/вправо" асинхронно). Это проверит, насколько правильно организована система ввода и событий – возможно, потребуется буферизация или обработка нескольких нажатий за кадр.
5. **Удаление линий и счет:** Реализовать проверку заполненных горизонтальных линий после каждого падения фигуры. Если линия заполнена полностью – удалить ее (в массиве или удалить соответствующие сущности блоков), опустить все верхние блоки вниз на 1. Начислить очки игроку. **UI:** Отобразить счет (например, 100 очков за линию) и счетчик удаленных линий или уровень. Это задействует подсистему UI: сущность с компонентом Text, обновляемая при изменении счета.
6. **Звук:** Встроить аудио-эффекты: короткий звук при установке фигуры или удалении линии, мелодию на фоне (например, фрагмент *Korobeiniki* как в классическом Tetris, если доступен без нарушений авторских прав). Проверить работу аудиосистемы: многократное воспроизведение звуков не должно приводить к ошибкам (потому что в Tetris могут одновременно удаляться несколько линий -> несколько звуков). Настроить ограничение, например, чтобы накладывающиеся звуки микшировались.
7. **Ускорение падения и геймплей:** Добавить возможность ускорять падение фигуры (клавиша «вниз») – это потребует отслеживать удержание клавиши для быстрого падения. Такие детали проверят, насколько легко расширять логику ввода и игровую систему.
8. **Сериализация фигур:** Опционально, использовать систему сериализации: хранить шаблоны тетромино во внешнем файле (например, JSON со списками координат блоков для каждой фигуры). Это покажет, как удобно загружать данные через движок. Можно также сохранять рекордные счета в файл.
9. **Тестирование Tetris:** Многократно поиграть в реализованный Tetris, проверяя корректность механики. Логирование пригодится для отладки сложных случаев (например, падение фигуры, удаление линий – логировать координаты, состояния массива). Убедиться, что при увеличении количества блоков производительность не падает (если падает – оптимизировать рендер или логику, это опыт оптимизации). Проверить, что звук и графика работают одновременно без конфликтов (возможно, выявятся проблемы с мультимедиа, тогда скорректировать – например, ограничить число одновременно играющих звуков).

**Модули движка в Tetris:**

* *ECS:* используется активно – каждая движущаяся фигура может быть сущностью, состоящей из компонентов блоков, или каждый блок – отдельная сущность. Tetris испытывает ECS на управление группами связанных сущностей (фигура из нескольких блоков), что может требовать улучшений (например, поддержки групповых компонентов или родительских сущностей).
* *Ввод:* система ввода проверяется более жёстко – требуются быстрые реакции и обработка нескольких команд за короткое время (удержание клавиш). Возможно, здесь понадобится доработать InputManager (например, ввод с задержкой для повторов – когда зажата клавиша, сначала срабатывает сразу, потом с небольшой паузой, затем авто-повтор – как в реальных Tetris).
* *Логика/события:* сложная игровая логика Tetris проверяет способность движка поддерживать нелинейные последовательности (вложенные события: фигура упала -> удалились линии -> начислить очки -> возможно, следующий уровень). Можно задействовать систему событий для упрощения: событие "LineCleared" обрабатывается системой счета, событие "LevelUp" – системой, увеличивающей скорость падения, и т.д. Таким образом движок демонстрирует модульную логику.
* *Рендеринг:* в Tetris одновременно на экране могут быть десятки объектов. Движок должен эффективно их рисовать. SFML справится с таким количеством спрайтов, но тут можно подумать о **батчинг-отрисовке** (оптимизация, не обязательна в учебном проекте).
* *Аудио:* впервые полноценно используется – проверяется удобство AudioManager (например, легко ли вызвать звук из игровой системы, нет ли задержек).
* *UI:* текстовый вывод на экран (счет, уровень) – тест работы текстового рендеринга.
* *Сериализация:* опционально задействуется для чтения конфигураций (фигуры, рекорды). Если реализована – проверяется интеграция IO с игрой.
* *Физика:* специализированный физический движок тут **не используется** – столкновения реализованы логически. Это хороший пример, что не всегда нужна тяжелая физика: достаточно проверки массива. Тем не менее, базовые функции столкновений, заложенные в этапе 4, могут не применяться здесь.

### Учебная игра 3: 2D-платформер

**Цели для движка:** Разработка простого **2D-платформера** станет кульминацией этапа 2D-развития движка. Платформер потребует использовать практически все подсистемы: **физику** (гравитация, столкновения персонажа с платформами), расширенную работу **ввода** (движение влево/вправо, прыжки), **анимацию спрайтов** (смена кадров при беге/прыжке), **AI** (если добавить простых врагов), **аудио** (звук прыжка, фоновой музыки), **UI** (отображение здоровья/очков), **сериализацию** (загрузка уровня из файла). Эта игра послужит испытанием интеграции всех модулей вместе и выявит, насколько хорошо спроектировано ядро.

**TODO – Задачи разработки 2D-платформера:**

1. **Дизайн уровня:** Создать простой уровень с платформами (блоками земли) и возможно препятствиями. Реализовать загрузку уровня из файла (например, матрица символов, где `'#'` – блок платформы, `'.'` – пустота). Сгенерировать сущности для каждого сегмента платформы (или объединять в более крупные блоки для производительности). Это проверит систему сериализации: чтение уровня и порождение множества игровых объектов.
2. **Главный персонаж:** Создать сущность *игрок* с компонентами: Position, Sprite/Animation, Physics (для движения по законам физики), PlayerController (для связи с вводом). Настроить спрайты для анимаций: например, 2-3 кадра для бега, кадр для прыжка. Добавить поддержку **анимации** в движке: компонент Animation (держит несколько текстур или кадр из единого спрайтлиста и скорость смены кадров) и систему AnimationSystem, которая будет переключать кадры по таймеру. Это расширение графического модуля.
3. **Движение и физика:** Задействовать физический движок (Bullet/Box2D) для гравитации и столкновений. Добавить постоянную силу тяжести, действующую на игрока (PhysicsSystem каждую секунду добавляет скорость падения). Настроить коллайдеры на платформах и на персонаже (например, прямоугольники). Проверить, что при падении персонаж останавливается на платформе, а не проваливается сквозь (для этого обрабатывать событие коллизии: при контакте снизу обнулить вертикальную скорость и зафиксировать позицию на поверхности).
4. **Управление персонажем:** Считать ввод для передвижения: стрелка влево/вправо – добавить горизонтальную скорость персонажу (или применять силу толчка в физике). Клавиша прыжка (например, пробел) – если персонаж на земле (можно отслеживать флаг «onGround» по коллизиям), придать ему импульс вверх. Таким образом, ввод воздействует на физическую модель персонажа. Убедиться, что InputManager и Physics взаимодействуют гармонично (возможно, понадобится настроить *Physics timestep*, чтобы прыжок был одинаковым при разном FPS).
5. **Враги и препятствия (опционально):** Для полноты добавить простого противника (например, гуляющий туда-сюда NPC) или движущиеся опасности. Это сущность *enemy* с компонентами Position, Sprite, Physics, AI. Реализовать простой **AI**: двигаться взад-вперед по платформе, менять направление при краю или столкновении со стеной. Столкновение игрока с врагом – событие потери здоровья. Это задействует события и, возможно, теги (компонент Tag или идентификатор типа объекта, чтобы отличить коллизии игрок-враг от прочих).
6. **Аудио и эффекты:** Добавить звук прыжка, звук при получении урона, фоновую музыку уровня. Также можно добавить простые эффекты – например, частицы при приземлении (хотя бы визуально: несколько маленьких спрайтов, возникающих на короткое время – проверить, насколько легко в движке создавать временные эффектные сущности).
7. **UI (HUD):** Отобразить на экране важную информацию: полоску здоровья персонажа или количество жизней, счет (например, за собранные предметы или поверженных врагов). Сделать простейший интерфейс: иконки жизней или текст «Health: 100». Также реализовать экран **Pause/Menu**: при нажатии ESC игра ставится на паузу и показывается меню (Resume, Exit). Это проверит гибкость движка в переключении состояний игры – можно реализовать через систему состояний (State Machine) или просто флаг `isPaused` в игровом цикле, при котором останавливается обновление мира, но работает UI.
8. **Концовка уровня:** Определить условие победы (например, достичь правого края уровня или собрать все объекты) и поражения (потеря всех жизней). Реализовать соответствующие экраны или сообщения (например, «Level Complete!» или «Game Over» с предложением перезапуска). Это потребует от движка уметь уничтожать/рестартовать текущую сцену, что можно сделать пересозданием всех сущностей или загрузкой уровня заново.
9. **Тестирование платформера:** Провести тщательное тестирование, так как здесь больше всего взаимодействий. Проверить движения, коллизии (нет ли застреваний в платформах, корректно ли реагирует на углы), реакцию на ввод (прыжок не отзывается с задержкой?). Отладочные инструменты очень пригодятся: нарисовать границы коллайдеров, логировать координаты, состояния onGround, выводить FPS. По итогам тестирования, возможно, оптимизировать: например, в PhysicsSystem использовать **spatial partitioning** (квадротдельное дерево или grid) если столкновений много; в рендеринге реализовать камеру (SFML View) ограничивающую отрисовку только видимой области, если уровень большой.

**Модули движка в платформере:**

* *Физика:* это главный экзамен для физической подсистемы. Если используется Bullet/Box2D, важно убедиться, что интеграция корректна: объекты не проходят сквозь друг друга, производительность приемлема. Много тонкостей может всплыть (например, «дрожание» объекта на платформе из-за погрешностей) – их решают настройкой физических параметров (масса, damping, разрешение коллизий).
* *ECS:* множество разнообразных сущностей (игрок, враги, платформы, предметы, эффекты). Проверяется, насколько удобно расширять ECS новыми компонентами (например, компонент Health для здоровья, AIComponent для поведения врага). Если архитектура правильная, добавление новых систем не нарушит существующие.
* *Ввод:* проверяется комплексно – одновременно может быть задействовано несколько действий (движение + прыжок + возможно стрельба, если добавить). Должна быть плавность управления.
* *Анимация:* новый аспект – система анимации графики. Это расширение рендеринга: убедиться, что при смене кадров спрайты обновляются, и это не конфликтует с остальными системами.
* *Аудио:* одновременное воспроизведение нескольких звуков (фон + эффекты) – тест звуковой подсистемы на смешивание. Также 3D-звук OpenAL мог бы быть применен, например, делать затухание звука с расстоянием, если уровень широкий (в 2D это можно симулировать по X координате – опционально).
* *UI:* используется для HUD и меню – проверка, что UI-элементы могут обновляться (здоровье уменьшается и отображается).
* *События:* активно используются – коллизии генерируют события повреждения, сбор предметов – события увеличения счета, нажатие паузы – событие остановки игры и включения меню. Это показывает, насколько удобно событийному механизму связывать разные системы (например, Physics -> HealthSystem -> UISystem при уроне).
* *Сериализация:* задействована на уровне загрузки карты. Если все работает, значит подсистема ввода-вывода правильно интегрирована.

### Другие возможные мини-игры и расширения

После успешной реализации вышеперечисленных игр движок EnoddGameEngine приобретет зрелость в 2D. Далее можно планировать более сложные проекты или новые функции, расширяя движок. Например:

* **Мини-игра 4: Top-down шутер** – игра с видом сверху (наподобие Asteroids или Space Invaders). Цель – проверить работу движка с большим числом снарядов/врагов, тестирование производительности ECS при множестве объектов, реализация системы частиц (взрывы) и, возможно, **сетевого режима** (если делать кооператив). Это добавит модуль **сети** (Network, можно использовать SFML Network).
* **Мини-игра 5: 3D-демо** – если планируется переход к 3D, небольшой проект (например, от первого лица бродилка по комнате) проверит способность использовать 3D-рендеринг. Придётся заменить или существенно расширить графический модуль (использовать OpenGL напрямую вместе с окном SFML) и включить 3D-функционал Bullet. Это крупное расширение, которое можно проводить, опираясь на накопленный опыт 2D.
* **Редактор уровней** – утилита на основе движка, позволяющая визуально создавать уровни для игр. Этот шаг улучшит **UI-модуль** (нужны интерактивные элементы), **сериализацию** (сохранение сделанного уровня) и общую гибкость движка как инструмента.

Такие проекты не обязательны в рамках обучения, но они помогут выявить новые требования и области улучшения (например, необходимость оптимизации, *горячей перезагрузки* ресурсов, более продвинутого рендеринга и т.д.).

## Последовательность разработки и зависимости

Порядок реализации движка и игр выстроен так, чтобы каждая следующая ступень опиралась на предыдущую. Ниже приведена примерная последовательность шагов и их взаимосвязи:

| Шаг                                               | Описание работы                                                                                  | Зависимости и переходы                                                                                                                                                          |
| ------------------------------------------------- | ------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **1. MVP ядра**                                   | Реализация минимального движка: окно, рендер, ECS, базовый ввод.                                 | *(Начало)* – закладывает фундамент для всех игр.                                                                                                                                |
| **2. Игра «Змейка»**                              | Создание первой игры на MVP-движке. Тест основы (цикл, ECS, ввод, рендер).                       | Требует завершения шага 1.<br/>**Результат:** выявляются улучшения для ввода, обнаруживаются базовые баги.                                                                      |
| **3. Расширение движка**<br/>*(ввод, аудио, UI)*  | Доработка ядра: полноценный InputManager, добавление аудио и базового UI (текст).                | Выполняется после опыта со «Змейкой»: учитывает необходимые улучшения (напр. сглаживание ввода). Аудио/UI готовят движок к Tetris.                                              |
| **4. Игра Tetris**                                | Разработка Tetris с использованием обновленных модулей (звук, UI, улучшенный ввод).              | Требует реализованных ввода и аудио (шаг 3).<br/>**Результат:** тестируется работа звука, отрисовка множества объектов, сложная логика; возможно, появляются задачи для физики. |
| **5. Расширение движка**<br/>*(физика, анимация)* | Внедрение физического движка (Bullet/Box2D) и системы анимации спрайтов в ядро.                  | Выполняется после Tetris, когда назрела необходимость физики для платформера. Анимация готовится для персонажей.                                                                |
| **6. Игра 2D-платформер**                         | Создание платформера, интегрирующего физику, анимацию и все ранее созданные системы.             | Требует завершения шага 5 (физика).<br/>**Результат:** всесторонняя проверка всего движка; после успешного платформера движок считается устойчивым в 2D.                        |
| **7. Дополнения/рефакторинг**                     | Оптимизация, исправление выявленных проблем, улучшение архитектуры, подготовка к новым функциям. | После платформера возможно возвращение к ядру для улучшений (например, оптимизация ECS или рендера).                                                                            |
| **8. Новые возможности**                          | (Опционально) Расширение на новые жанры или 3D, сеть, редакторы и пр.                            | Требует уверенной работы предыдущих этапов; осуществляется при необходимости дальнейшего развития проекта.                                                                      |


---

## Этап 9. 3D-подсистема и гибкая камера

| Под-этап                                       | Цель                                                                | Ключевые работы                                                                                                                                                                                                                                                                                                                                                 | Желательные библиотеки                                                                                                                                               |
| ---------------------------------------------- | ------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **9-A. 3D рендер-ядро (MVP)**                  | Вывести на экран простой 3D-мир (меш + текстура) в собственном окне | 1. Абстрагируем слой рендеринга: изолируем SFML-окно + контекст.<br>2. Создаём базовый **Renderer3D** (Vulkan 1.3 или OpenGL 4.6).<br>3. Пишем минимальный пакет шейдеров: *unlit* и *simple-lit* (Lambert).<br>4. Импортируем статические меши из glTF (через tinygltf или Assimp).<br>5. Интегрируем с ECS: новая пара компонентов **Mesh**, **Transform3D**. | • **Vulkan (+VMA)** — если хочется сразу низкоуровневый контроль.<br>• ***Или*** OpenGL (+GLAD) — быстрее старт, проще шейдер-пайплайн.<br>• **GLM** для математики. |
| **9-B. Камера «Top-Down ⇄ OTS»**               | Позволить плавно переключаться между двумя ракурсами                | 1. Реализуем **CameraSystem** с параметрами:<br>  • режим *TOP\_DOWN*: ортогональная проекция под углом 90°.<br>  • режим *OTS* (over-the-shoulder): перспектива≈45°, позиция над плечом.<br>2. Скрипт-плавник: колесо мыши → плавный LERP FOV + позиция.<br>3. Блокируем/разблокируем курсор при приближении (комфорт).                                        |                                                                                                                                                                      |
| **9-C. Простая 3D-физика**                     | Коллизии и парочка движущихся тел                                   | 1. Подключаем **Bullet** в 3D-режиме (сохранится совместимость с 2D).<br>2. Компонент **RigidBody3D** (масса, форма).<br>3. Система Physics3D обновляет мир Bullet.<br>4. Событие *OnCollision3D* → игровая логика.                                                                                                                                             |                                                                                                                                                                      |
| **9-D. Освещение и материалы «без наворотов»** | Базовая визуальная читаемость                                       | 1. Один directional light + ambient.<br>2. Простая модель материала: альбедо-текстура + Lambert diffuse.<br>3. Тонкая настройка гаммы/тон-маппинга позже.                                                                                                                                                                                                       |                                                                                                                                                                      |
| **9-E. Контент-поток**                         | Быстрый импорт low-poly ассетов                                     | 1. Скрипт-конвертер glTF → двоичный кэш движка.<br>2. Авто-проверка на запредельное число треугольников.<br>3. Генерация LOD (по желанию).                                                                                                                                                                                                                      |                                                                                                                                                                      |
| **9-F. Инструменты**                           | Удобство разработки 3D-игр                                          | 1. Отладочный рендер коллизионных мешей.<br>2. Gizmo-манипуляторы (позиция / угол) через ImGui.                                                                                                                                                                                                                                                                 |                                                                                                                                                                      |








| №        | Примитивная 3D-игра                               | Цель для движка                                                                                                                                                    | Новые подсистемы / API                                                                                                                                                                    | Шаблонный гейм-цикл (≈60 мин)                                                                                                  |
| -------- | ------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------ |
| **3D-0** | **Voxel Sandbox**<br>\*(туториальный «песочница») | 🔸Первый «smoke-test» плагина:<br>– загрузка и линковка 3D-модуля;<br>– базовый forward-renderer;<br>– конвертор **glTF → internal**;<br>– UI-переключатель 2D/3D. | • Плагин `Renderer3D` (dll/so).<br>• Компоненты `Mesh`, `Transform3D`.<br>• Орто-камера TOP-DOWN.<br>• Импорт ассетов из `/Assets/voxels/…`.<br>• Вызовы «горячего» включения/отключения. | Игрок строит/ломает 30 мин блоки-кубы, исследуя освещение и смену проекций.                                                    |
| **3D-1** | **Maze Runner**                                   | 🔸Тест камеры-зуммера TOP-DOWN ⇄ OTS.<br>🔸Коллизии + навигация.                                                                                                   | • `CameraSystem3D` (LERP FOV).<br>• Bullet 3D капсульный коллайдер.<br>• Простая A\* AI-патруль (2–3 противника).<br>• Расчёт нав-решётки offline.                                        | 20-клеточный лабиринт, таймер-квест «найди выход» + три жизни. Средняя сессия \~ 50 мин, т. к. лабиринт генерируется случайно. |
| **3D-2** | **Wave Arena**                                    | 🔸Десятки вражеских мешей ⇒ стресс ECS+renderer.<br>🔸События «spawn/death», частицы, звук.                                                                        | • Система `ParticleEmitter`.<br>• Батчинг в `Renderer3D` (instancing).<br>• `Audio3D` (OpenAL прямое позиционирование).<br>• Менеджер «волн» (spawn API).                                 | Игрок держится 10 волн по 3-5 мин. Камера свободно масштабируется; каждый зум проверяет ЛОД.                                   |
| **3D-3** | **Low-Poly Kart**                                 | 🔸Первое «транспортное» тело в Bullet.<br>🔸Spline-трек и «гладкая» камера-след.                                                                                   | • Усовершенствованный `PhysicsVehicle` (лучи-колёса).<br>• `SplinePathComponent` + интерполятор.<br>• Motion-blur пост-обработка.                                                         | Узкое кольцо \~ 3 км, 5 кругов = 25–30 мин. Прокрутка картинок на HUD (счёт, круг).                                            |
| **3D-4** | **Micro-Dungeon**                                 | 🔸Комбинируем всё: ближний бой, дальний, босс-комната.<br>🔸Система лута, сохранение прогресса (JSON save).                                                        | • `InventoryComponent` + UI-слой 3D‐HUD.<br>• NavMesh-генерация (Recast).<br>• Сериализация 3D-состояния (`SaveGame3D`).                                                                  | 4 процедурных зала, один финальный босс. Проход \~ 45-60 мин. Позволяет полноценно «прощупать» часовой цикл.                   |
